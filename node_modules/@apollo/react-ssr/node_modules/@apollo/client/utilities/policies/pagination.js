import { __assign, __spreadArrays } from "tslib";
import { __rest } from "tslib";
export function concatPagination(keyArgs) {
    if (keyArgs === void 0) { keyArgs = false; }
    return {
        keyArgs: keyArgs,
        merge: function (existing, incoming) {
            return existing ? __spreadArrays(existing, incoming) : incoming;
        },
    };
}
export function offsetLimitPagination(keyArgs) {
    if (keyArgs === void 0) { keyArgs = false; }
    return {
        keyArgs: keyArgs,
        merge: function (existing, incoming, _a) {
            var args = _a.args;
            var merged = existing ? existing.slice(0) : [];
            var start = args ? args.offset : merged.length;
            var end = start + incoming.length;
            for (var i = start; i < end; ++i) {
                merged[i] = incoming[i - start];
            }
            return merged;
        },
    };
}
export function relayStylePagination(keyArgs) {
    if (keyArgs === void 0) { keyArgs = false; }
    return {
        keyArgs: keyArgs,
        read: function (existing, _a) {
            var canRead = _a.canRead, readField = _a.readField;
            if (!existing)
                return;
            var edges = [];
            var startCursor = "";
            var endCursor = "";
            existing.wrappers.forEach(function (wrapper) {
                if (canRead(readField("node", wrapper.edge))) {
                    edges.push(wrapper.edge);
                    if (wrapper.cursor) {
                        startCursor = startCursor || wrapper.cursor;
                        endCursor = wrapper.cursor;
                    }
                }
            });
            return __assign(__assign({}, getExtras(existing)), { edges: edges, pageInfo: __assign(__assign({}, existing.pageInfo), { startCursor: startCursor,
                    endCursor: endCursor }) });
        },
        merge: function (existing, incoming, _a) {
            if (existing === void 0) { existing = makeEmptyData(); }
            var args = _a.args, readField = _a.readField;
            var incomingWrappers = incoming.edges ? incoming.edges.map(function (edge) { return ({
                edge: edge,
                cursor: readField("cursor", edge),
            }); }) : [];
            if (incoming.pageInfo) {
                var _b = incoming.pageInfo, startCursor = _b.startCursor, endCursor = _b.endCursor;
                var firstWrapper_1 = incomingWrappers[0];
                if (firstWrapper_1 && startCursor) {
                    firstWrapper_1.cursor = startCursor;
                }
                var lastWrapper_1 = incomingWrappers[incomingWrappers.length - 1];
                if (lastWrapper_1 && endCursor) {
                    lastWrapper_1.cursor = endCursor;
                }
            }
            var prefix = existing.wrappers;
            var suffix = [];
            if (args && args.after) {
                var index = prefix.findIndex(function (wrapper) { return wrapper.cursor === args.after; });
                if (index >= 0) {
                    prefix = prefix.slice(0, index + 1);
                }
            }
            else if (args && args.before) {
                var index = prefix.findIndex(function (wrapper) { return wrapper.cursor === args.before; });
                suffix = index < 0 ? prefix : prefix.slice(index);
                prefix = [];
            }
            else if (incoming.edges) {
                prefix = [];
            }
            var wrappers = __spreadArrays(prefix, incomingWrappers, suffix);
            var firstWrapper = wrappers[0];
            var lastWrapper = wrappers[wrappers.length - 1];
            var pageInfo = __assign(__assign(__assign({}, incoming.pageInfo), existing.pageInfo), { startCursor: firstWrapper && firstWrapper.cursor || "", endCursor: lastWrapper && lastWrapper.cursor || "" });
            if (incoming.pageInfo) {
                var _c = incoming.pageInfo, hasPreviousPage = _c.hasPreviousPage, hasNextPage = _c.hasNextPage;
                if (!prefix.length && hasPreviousPage !== void 0) {
                    pageInfo.hasPreviousPage = hasPreviousPage;
                }
                if (!suffix.length && hasNextPage !== void 0) {
                    pageInfo.hasNextPage = hasNextPage;
                }
            }
            return __assign(__assign(__assign({}, getExtras(existing)), getExtras(incoming)), { wrappers: wrappers,
                pageInfo: pageInfo });
        },
    };
}
var getExtras = function (obj) { return __rest(obj, notExtras); };
var notExtras = ["edges", "wrappers", "pageInfo"];
function makeEmptyData() {
    return {
        wrappers: [],
        pageInfo: {
            hasPreviousPage: false,
            hasNextPage: true,
            startCursor: "",
            endCursor: "",
        },
    };
}
//# sourceMappingURL=pagination.js.map